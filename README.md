# YACodeRun 166. Яндексформеры

* **лёгкая**
* sort
* algorithms
* first_2023_frontend

Яндексоиды научились образовывать Гештальд. Гештальд — это когда разработчики меньшего уровня собираются в одного Яндексформера и решают большую и сложную задачу. У каждого яндексоида есть свой грейд. Грейд яндексоида - это целое число, обозначающее максимальный уровень задачи, которую сотрудник способен решить. Грейд же Яндексформера - это сумма грейдов входящих в гештальд.

Проблема в том, что для Яндексформера нужен компьютер с **K** клавиатурами, где **K** — число яндексоидов в объединении. Клавиатур меньше чем Яндексоидов, поэтому необходимо определить максимально возможный уровень Яндексформера, доступного для сборки.

**Например:**

Пусть доступны разработчики с грейдами **[**10**,**1**,**23**,**0**,**1**]**, а также **2** клавиатуры. В таком случае оптимально будет объединить в гештальд разработчиков с грейдами **10** и **23** - уровень Яндексформера будет равен **33**.

Шаблон кода

```
/**
* @param {number} N - целое число, количество сотрудников, готовых к объединению
* @param {number[]} staff - массив длины N с грейдами доступных сотрудников
* @param {number} K - целое число, количество доступных клавиатур
* @returns {number}
*/
module.exports = function (N, staff, K) {
    // Ваш код

    return x // x - максимальный уровень Яндексформера
}
```

### Формат ввода

На вход функции подаются три параметра:

* целое число **N** (**1**≤**N**≤**1**0^**7**+**100**) - количество сотрудников, готовых к объединению;
* массив целых чисел **s**t**a**ff (**0**≤**s**t**a**ff[**i**]≤**25**) - список грейдов сотрудников, готовых к объединению;
* целое число **K** (**1**≤**K**≤**N**) - количество доступных клавиатур.

### Формат вывода

Функция должна вернуть единственное целое число - максимально возможный уровень Яндексформера при объединении �**K** разработчиков.

## Пример 1

Ввод

```
{"N": 8, "staff": [5, 13, 8, 4, 4, 15, 1, 9], "K": 8}
```

Вывод

```
{"ans": 59}
```

## Пример 2

Ввод

```
{"N": 11, "staff": [14, 8, 15, 19, 2, 21, 13, 21, 12, 10, 8], "K": 5}
```

Вывод

```
{"ans": 90}
```

## Пример 3

Ввод

```
{"N": 15, "staff": [19, 20, 5, 10, 2, 20, 7, 9, 1, 3, 13, 14, 3, 3, 4], "K": 1}
```

Вывод

```
{"ans": 20}
```

## Пример 4

Ввод

```
{"N": 12, "staff": [22, 7, 24, 24, 11, 22, 24, 3, 9, 16, 2, 19], "K": 7}
```

Вывод

```
{"ans": 151}
```

## Пример 5

Ввод

```
{"N": 7, "staff": [10, 3, 21, 23, 6, 3, 8], "K": 4}
```

Вывод

```
{"ans": 62}
```

# Результат

Пожалуй такоего результата мало кто ожидает. Для тех кому лень читать дальше, можете просто открыть файл Result.js.

###### Акт первый. Все как по учебнику.

Когда прочитал задание решил "Пфф... ща за 15 минут все напишу...", и написалиспользовал старый добрый метод `sort()`, и в VS Code все приведенные в задании примеры отработали на Ура. Закидываю получившийся коротенький код на платформу [CodeRunYandex](https://coderun.yandex.ru/) и отправляю на тесты, спустя пару минут получаю результат **"Time limit exceeded"** переводя на доступный русский, мой код выполнялся дольше отведенных 3х секунд. Открыл лог выполнения тестов, на 40 тесте вижу надпись **"Time limit exceeded"**, и собственно всё, больше никакой информации по ошибке нет. Обратил внимание на другие тесты все длились не более 300мс., а тут неожиданно тест длился более 3 секунд. "Или я дурак или платформа косячит" - подумал я. Ладно попробуем написать свою фильтрацию с блэк-джеком и девушками низкой социальной ответственности.

###### И так акт второй. Пробуем классику сортировки.

Написал код функции пузырьковой сортировки отправил на тесты... иииииии... барабанная дробь... да да да пошел я нахер со своей пузырьковой сортировкой. На этот раз я был послан платформой еще раньше чем в прошлый 20/88 тестов, ошибка все та же **"Time limit exceeded".**

Написал код сортировки выбором и получил в ответ от платформы [CodeRunYandex](https://coderun.yandex.ru/) что? Верно: **"Time limit exceeded".**

Сходил в яндекс почитал про другие классиеские варианты сортировки и понял что первые 3 попытки которые провалились с треском были очень даже хорошими, а другие варианты алгоритмов сортировки уже сложнее и далеко не все подходят под задачу. 

Тут нужно выдумывать нечно особенное конкретно под это задание.

###### Акт третий, крайний. Пишем несусветную дичь.

Результат который в итоге прошел все тесты как по мне несусветная дичь. имхо такой способ сортировки я лично не хотел бы применять в реальных проектах но тем не менее оно работает и даже прошло все тесты.

```js
const checkGraids = (graidsArray) => {
    let result = false;
    graidsArray.forEach((graid) => {
        if (graid >= 0 && graid <= 25) {
            result = true;
        }
    });
    return result;
}

/**
* @param {number} N - целое число, количество сотрудников готовых к объединению
* @param {number[]} staff - массив длины N с грейдами доступных сотрудников
* @param {number} K - целое число, количество доступных клавиатур
* @returns {number}
*/
module.exports = function (N, staff, K) {
    if (
        (N >= 1 && N <= (10 ** 7 + 100)) &&
        checkGraids(staff) &&
        (K >= 1 && K <= N)
    ) {
        let result = 0;         // тут будем хранить результат
        let obj = {};           // объект ключами будут возможные значения грейдов, а значениями будут их количество
        let objKeys = [];       // ключи объекта пихнем сюда

        for (i = 0; i < staff.length; i++) {    // перебираем наши грейды
            if (obj[staff[i]]) {                // если в объекте уже есть ключ равный грейду
                obj[staff[i]]++;                // то увеличим его значение на 1
            }
            else {                              // если в ключ равный грейду встречаем впервые 
                obj[staff[i]] = 1;              // то создаем новую пару ключ значение 
            }
        }

        objKeys = Object.keys(obj);         // соберем все возможные значения грейдов в один массив из за того что собираем из объекта то получаем уже отсортированный массив

        for (i = objKeys.length; i > 0; i--) {  // перебираем возможные значения грейдов от большего к меньшему
            if (K >= obj[objKeys[i - 1]]) {     // если K (клавиатур) больше или равно количеству разработчиков итерируемого грейда
                result += objKeys[i - 1] * obj[objKeys[i - 1]]; // то к результату прибавим произведение грейда и количества разработчиков с этим грейдом
                K -= obj[objKeys[i - 1]];       // отнимаем от K (количества свободных клавиатур) количество разрабов итерируемого грейда
            }
            else {                              // если K (клавиатур) меньше количества разработчиков итерируемого грейда
                result += objKeys[i - 1] * K;   // то к результату прибавим произведение грейда и количества свободных клавиатур
                break;                          // и выходим из цикла
            }
        }
        return result;                          // вернем результат
    }
    else {
        return 'Ошибка входных значений!';
    }
}

```
